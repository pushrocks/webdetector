{"id":"../node_modules/@pushrocks/lik/dist/lik.tree.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/ts/lik.tree.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/package.json","includedInParent":true,"mtime":1545395695572},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/package.json","includedInParent":true,"mtime":1545395355371},{"name":"./lik.plugins","loc":{"line":3,"column":24},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/dist/lik.tree.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/dist/lik.plugins.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst plugins = require(\"./lik.plugins\");\nclass Tree {\n    constructor() {\n        this.symbolTree = new plugins.symbolTree();\n    }\n    // =======================================\n    // Functions that map to the functionality of symbol-tree\n    // =======================================\n    /**\n     *\n     * @param objectArg\n     */\n    initialize(objectArg) {\n        return this.symbolTree.initialize(objectArg);\n    }\n    hasChildren(objectArg) {\n        return this.symbolTree.hasChildren(objectArg);\n    }\n    firstChild(objectArg) {\n        return this.symbolTree.firstChild(objectArg);\n    }\n    lastChild(objectArg) {\n        return this.symbolTree.lastChild(objectArg);\n    }\n    previousSibling(objectArg) {\n        return this.symbolTree.previousSibling(objectArg);\n    }\n    nextSibling(objectArg) {\n        return this.symbolTree.nextSibling(objectArg);\n    }\n    parent(objectArg) {\n        return this.symbolTree.parent(objectArg);\n    }\n    lastInclusiveDescendant(objectArg) {\n        return this.symbolTree.lastInclusiveDescendant(objectArg);\n    }\n    preceding(objectArg, optionsArg) {\n        return this.symbolTree.preceding(objectArg, optionsArg);\n    }\n    following(object, optionsArg) {\n        return this.symbolTree.following(object, optionsArg);\n    }\n    childrenToArray(parentArg, optionsArg) {\n        return this.symbolTree.childrenToArray(parentArg, optionsArg);\n    }\n    ancestorsToArray(objectArg, optionsArg) {\n        return this.symbolTree.ancestorsToArray(objectArg, optionsArg);\n    }\n    treeToArray(rootArg, optionsArg) {\n        return this.symbolTree.treeToArray(rootArg, optionsArg);\n    }\n    childrenIterator(parentArg, optionsArg) {\n        return this.symbolTree.childrenIterator(parentArg, optionsArg);\n    }\n    previousSiblingsIterator(objectArg) {\n        return this.symbolTree.previousSiblingsIterator(objectArg);\n    }\n    nextSiblingsIterator(objectArg) {\n        return this.symbolTree.nextSiblingsIterator();\n    }\n    ancestorsIterator(objectArg) {\n        this.symbolTree.ancestorsIterator();\n    }\n    treeIterator(rootArg, optionsArg) {\n        return this.symbolTree.treeIterator(rootArg);\n    }\n    index(childArg) {\n        return this.symbolTree.index(childArg);\n    }\n    childrenCount(parentArg) {\n        return this.symbolTree.childrenCount(parentArg);\n    }\n    compareTreePosition(leftArg, rightArg) {\n        return this.compareTreePosition(leftArg, rightArg);\n    }\n    remove(removeObjectArg) {\n        return this.symbolTree.remove(removeObjectArg);\n    }\n    insertBefore(referenceObjectArg, newObjectArg) {\n        return this.symbolTree.insertBefore(referenceObjectArg, newObjectArg);\n    }\n    insertAfter(referenceObject, newObjectArg) {\n        return this.symbolTree.insertAfter(referenceObject, newObjectArg);\n    }\n    prependChild(referenceObjectArg, newObjectArg) {\n        return this.symbolTree.prependChild(referenceObjectArg, newObjectArg);\n    }\n    appendChild(referenceObjectArg, newObjectArg) {\n        return this.symbolTree.appendChild(referenceObjectArg, newObjectArg);\n    }\n    // ===========================================\n    // Functionionality that extends symbol-tree\n    // ===========================================\n    /**\n     * returns a branch of the tree as JSON\n     * can be user\n     */\n    toJsonWithHierachy(rootElement) {\n        const treeIterable = this.treeIterator(rootElement, {});\n        for (const treeItem of treeIterable) {\n            console.log(treeItem);\n        }\n    }\n    /**\n     * builds a tree from a JSON with hierachy\n     * @param rootElement\n     */\n    fromJsonWithHierachy(rootElement) { }\n}\nexports.Tree = Tree;\n","map":{"version":3,"file":"lik.tree.js","sourceRoot":"","sources":["../ts/lik.tree.ts"],"names":[],"mappings":"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","sourcesContent":["import * as plugins from './lik.plugins';\n\nexport class Tree<T> {\n  symbolTree: any;\n  constructor() {\n    this.symbolTree = new plugins.symbolTree();\n  }\n\n  // =======================================\n  // Functions that map to the functionality of symbol-tree\n  // =======================================\n\n  /**\n   *\n   * @param objectArg\n   */\n  initialize(objectArg: T): T {\n    return this.symbolTree.initialize(objectArg);\n  }\n\n  hasChildren(objectArg: T): boolean {\n    return this.symbolTree.hasChildren(objectArg);\n  }\n\n  firstChild(objectArg: T): T {\n    return this.symbolTree.firstChild(objectArg);\n  }\n\n  lastChild(objectArg: T): T {\n    return this.symbolTree.lastChild(objectArg);\n  }\n\n  previousSibling(objectArg: T): T {\n    return this.symbolTree.previousSibling(objectArg);\n  }\n\n  nextSibling(objectArg: T): T {\n    return this.symbolTree.nextSibling(objectArg);\n  }\n\n  parent(objectArg: T): T {\n    return this.symbolTree.parent(objectArg);\n  }\n\n  lastInclusiveDescendant(objectArg: T): T {\n    return this.symbolTree.lastInclusiveDescendant(objectArg);\n  }\n\n  preceding(objectArg: T, optionsArg?: any): T {\n    return this.symbolTree.preceding(objectArg, optionsArg);\n  }\n\n  following(object: T, optionsArg: any) {\n    return this.symbolTree.following(object, optionsArg);\n  }\n\n  childrenToArray(parentArg: T, optionsArg: any): T[] {\n    return this.symbolTree.childrenToArray(parentArg, optionsArg);\n  }\n\n  ancestorsToArray(objectArg: T, optionsArg: any): T[] {\n    return this.symbolTree.ancestorsToArray(objectArg, optionsArg);\n  }\n\n  treeToArray(rootArg, optionsArg: any): T[] {\n    return this.symbolTree.treeToArray(rootArg, optionsArg);\n  }\n\n  childrenIterator(parentArg: T, optionsArg): T {\n    return this.symbolTree.childrenIterator(parentArg, optionsArg);\n  }\n\n  previousSiblingsIterator(objectArg): T {\n    return this.symbolTree.previousSiblingsIterator(objectArg);\n  }\n\n  nextSiblingsIterator(objectArg: T) {\n    return this.symbolTree.nextSiblingsIterator();\n  }\n\n  ancestorsIterator(objectArg) {\n    this.symbolTree.ancestorsIterator();\n  }\n\n  treeIterator(rootArg: T, optionsArg): Iterable<T> {\n    return this.symbolTree.treeIterator(rootArg);\n  }\n\n  index(childArg: T): number {\n    return this.symbolTree.index(childArg);\n  }\n\n  childrenCount(parentArg: T): number {\n    return this.symbolTree.childrenCount(parentArg);\n  }\n\n  compareTreePosition(leftArg: T, rightArg: T): number {\n    return this.compareTreePosition(leftArg, rightArg);\n  }\n\n  remove(removeObjectArg: T): T {\n    return this.symbolTree.remove(removeObjectArg);\n  }\n\n  insertBefore(referenceObjectArg: T, newObjectArg: T): T {\n    return this.symbolTree.insertBefore(referenceObjectArg, newObjectArg);\n  }\n\n  insertAfter(referenceObject: T, newObjectArg: T) {\n    return this.symbolTree.insertAfter(referenceObject, newObjectArg);\n  }\n\n  prependChild(referenceObjectArg: T, newObjectArg: T): T {\n    return this.symbolTree.prependChild(referenceObjectArg, newObjectArg);\n  }\n\n  appendChild(referenceObjectArg, newObjectArg) {\n    return this.symbolTree.appendChild(referenceObjectArg, newObjectArg);\n  }\n\n  // ===========================================\n  // Functionionality that extends symbol-tree\n  // ===========================================\n\n  /**\n   * returns a branch of the tree as JSON\n   * can be user\n   */\n  toJsonWithHierachy(rootElement) {\n    const treeIterable = this.treeIterator(rootElement, {});\n    for (const treeItem of treeIterable) {\n      console.log(treeItem);\n    }\n  }\n\n  /**\n   * builds a tree from a JSON with hierachy\n   * @param rootElement\n   */\n  fromJsonWithHierachy(rootElement) {}\n}\n"]}},"hash":"ea232779939b9b2ad6f74a0933e20c50","cacheData":{"env":{}}}