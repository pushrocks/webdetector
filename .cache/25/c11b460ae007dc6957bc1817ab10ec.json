{"id":"../node_modules/@pushrocks/smartrx/dist/smartrx.classes.observableintake.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/ts/smartrx.classes.observableintake.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/package.json","includedInParent":true,"mtime":1545395695572},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/package.json","includedInParent":true,"mtime":1545395355372},{"name":"./smartrx.plugins","loc":{"line":3,"column":24},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/dist/smartrx.classes.observableintake.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/dist/smartrx.plugins.js"},{"name":"rxjs","loc":{"line":4,"column":23},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/dist/smartrx.classes.observableintake.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/rxjs/_esm5/index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst plugins = require(\"./smartrx.plugins\");\nconst rxjs_1 = require(\"rxjs\");\n/**\n * ObservableIntake\n */\nclass ObservableIntake {\n    constructor() {\n        this.observableFunctions = {\n            next: payloadArg => {\n                // nothing\n            },\n            complete: payloadArg => {\n                // nothing\n            }\n        };\n        this.generator = null;\n        this.buffered = false;\n        this.payloadBuffer = [];\n        this.observable = rxjs_1.Observable.create(observerArg => {\n            this.observableFunctions.next = (...args) => {\n                return observerArg.next(...args);\n            };\n            this.observableFunctions.complete = (...args) => {\n                this.completedDeffered.resolve();\n                return observerArg.complete(...args);\n            };\n        });\n        this.completedDeffered = plugins.smartpromise.defer();\n        this.completed = this.completedDeffered.promise;\n    }\n    setObservable(observableFunc) {\n        this.observable = observableFunc();\n    }\n    push(payloadArg) {\n        if (this.buffered) {\n            this.payloadBuffer.push(payloadArg);\n        }\n        else {\n            this.internalPush(payloadArg);\n        }\n    }\n    /**\n     * pushes many payloads as array\n     * @param payloadArgArray\n     */\n    pushMany(payloadArgArray) {\n        for (let item of payloadArgArray) {\n            this.push(item);\n        }\n    }\n    /**\n     * sets a generator to query the next pushed value\n     * @param generatorArg\n     */\n    setGenerator(generatorArg) {\n        this.generator = generatorArg;\n    }\n    makeBuffered() {\n        this.buffered = true;\n    }\n    subscribe(...args) {\n        return this.observable.subscribe(...args);\n    }\n    /**\n     * request the next values in the quantity specified\n     * @param howManyArg if a generator is set, of a buffer exists, this allows retrieving values\n     */\n    request(howManyArg) {\n        if (howManyArg === 0) {\n            return;\n        }\n        else {\n            for (let i = 0; i !== howManyArg; i++) {\n                if (this.payloadBuffer.length > 0) {\n                    this.internalPush(this.payloadBuffer.shift());\n                }\n                else {\n                    const nextPayload = this.generator();\n                    this.internalPush(nextPayload);\n                }\n            }\n        }\n    }\n    /**\n     * signals the completion of this observable\n     */\n    signalComplete() {\n        this.observableFunctions.complete();\n    }\n    internalPush(payloadArg) {\n        this.observableFunctions.next(payloadArg);\n    }\n}\nexports.ObservableIntake = ObservableIntake;\n","map":{"version":3,"file":"smartrx.classes.observableintake.js","sourceRoot":"","sources":["../ts/smartrx.classes.observableintake.ts"],"names":[],"mappings":";;AAAA,6CAA6C;AAC7C,+BAAgD;AAGhD;;GAEG;AACH,MAAa,gBAAgB;IAgB3B;QAZQ,wBAAmB,GAAQ;YACjC,IAAI,EAAE,UAAU,CAAC,EAAE;gBACjB,UAAU;YACZ,CAAC;YACD,QAAQ,EAAE,UAAU,CAAC,EAAE;gBACrB,UAAU;YACZ,CAAC;SACF,CAAC;QACM,cAAS,GAAG,IAAI,CAAC;QACjB,aAAQ,GAAG,KAAK,CAAC;QACjB,kBAAa,GAAG,EAAE,CAAC;QAGzB,IAAI,CAAC,UAAU,GAAG,iBAAU,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE;YAChD,IAAI,CAAC,mBAAmB,CAAC,IAAI,GAAG,CAAC,GAAG,IAAI,EAAE,EAAE;gBAC1C,OAAO,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;YACnC,CAAC,CAAC;YACF,IAAI,CAAC,mBAAmB,CAAC,QAAQ,GAAG,CAAC,GAAG,IAAI,EAAE,EAAE;gBAC9C,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,CAAC;gBACjC,OAAO,WAAW,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC;YACvC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;QACtD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC;IAClD,CAAC;IAED,aAAa,CAAC,cAAc;QAC1B,IAAI,CAAC,UAAU,GAAG,cAAc,EAAE,CAAC;IACrC,CAAC;IAED,IAAI,CAAC,UAAa;QAChB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SACrC;aAAM;YACL,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;SAC/B;IACH,CAAC;IAED;;;OAGG;IACH,QAAQ,CAAC,eAAoB;QAC3B,KAAK,IAAI,IAAI,IAAI,eAAe,EAAE;YAChC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACjB;IACH,CAAC;IAED;;;OAGG;IACH,YAAY,CAAC,YAAY;QACvB,IAAI,CAAC,SAAS,GAAG,YAAY,CAAC;IAChC,CAAC;IAED,YAAY;QACV,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACvB,CAAC;IAED,SAAS,CAAC,GAAG,IAAI;QACf,OAAO,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,CAAC;IAC5C,CAAC;IAED;;;OAGG;IACH,OAAO,CAAC,UAAkB;QACxB,IAAI,UAAU,KAAK,CAAC,EAAE;YACpB,OAAO;SACR;aAAM;YACL,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,UAAU,EAAE,CAAC,EAAE,EAAE;gBACrC,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;oBACjC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC;iBAC/C;qBAAM;oBACL,MAAM,WAAW,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;oBACrC,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;iBAChC;aACF;SACF;IACH,CAAC;IAED;;OAEG;IACH,cAAc;QACZ,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,CAAC;IACtC,CAAC;IAEO,YAAY,CAAC,UAAU;QAC7B,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC5C,CAAC;CACF;AAjGD,4CAiGC","sourcesContent":["import * as plugins from './smartrx.plugins';\nimport { Observable, Subscription } from 'rxjs';\nimport { Deferred } from 'smartq';\n\n/**\n * ObservableIntake\n */\nexport class ObservableIntake<T> {\n  observable: Observable<T>;\n  completed: Promise<void>;\n  private completedDeffered: Deferred<void>;\n  private observableFunctions: any = {\n    next: payloadArg => {\n      // nothing\n    },\n    complete: payloadArg => {\n      // nothing\n    }\n  };\n  private generator = null;\n  private buffered = false;\n  private payloadBuffer = [];\n\n  constructor() {\n    this.observable = Observable.create(observerArg => {\n      this.observableFunctions.next = (...args) => {\n        return observerArg.next(...args);\n      };\n      this.observableFunctions.complete = (...args) => {\n        this.completedDeffered.resolve();\n        return observerArg.complete(...args);\n      };\n    });\n    this.completedDeffered = plugins.smartpromise.defer();\n    this.completed = this.completedDeffered.promise;\n  }\n\n  setObservable(observableFunc) {\n    this.observable = observableFunc();\n  }\n\n  push(payloadArg: T) {\n    if (this.buffered) {\n      this.payloadBuffer.push(payloadArg);\n    } else {\n      this.internalPush(payloadArg);\n    }\n  }\n\n  /**\n   * pushes many payloads as array\n   * @param payloadArgArray\n   */\n  pushMany(payloadArgArray: T[]) {\n    for (let item of payloadArgArray) {\n      this.push(item);\n    }\n  }\n\n  /**\n   * sets a generator to query the next pushed value\n   * @param generatorArg\n   */\n  setGenerator(generatorArg) {\n    this.generator = generatorArg;\n  }\n\n  makeBuffered() {\n    this.buffered = true;\n  }\n\n  subscribe(...args) {\n    return this.observable.subscribe(...args);\n  }\n\n  /**\n   * request the next values in the quantity specified\n   * @param howManyArg if a generator is set, of a buffer exists, this allows retrieving values\n   */\n  request(howManyArg: number) {\n    if (howManyArg === 0) {\n      return;\n    } else {\n      for (let i = 0; i !== howManyArg; i++) {\n        if (this.payloadBuffer.length > 0) {\n          this.internalPush(this.payloadBuffer.shift());\n        } else {\n          const nextPayload = this.generator();\n          this.internalPush(nextPayload);\n        }\n      }\n    }\n  }\n\n  /**\n   * signals the completion of this observable\n   */\n  signalComplete() {\n    this.observableFunctions.complete();\n  }\n\n  private internalPush(payloadArg) {\n    this.observableFunctions.next(payloadArg);\n  }\n}\n"]}},"hash":"809210b8665bb5a53df4bc8dfef7094a","cacheData":{"env":{}}}