{"id":"../node_modules/@pushrocks/smartpromise/dist/index.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartpromise/ts/index.ts","includedInParent":true,"mtime":1530600267000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/package.json","includedInParent":true,"mtime":1545395695572},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartpromise/package.json","includedInParent":true,"mtime":1545395354775},{"name":"util","loc":{"line":11,"column":21},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartpromise/dist/index.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/util/util.js"}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util = require(\"util\");\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n            this.status = 'pending';\n        });\n    }\n}\nexports.Deferred = Deferred;\nexports.defer = () => {\n    return new Deferred();\n};\n/**\n * Creates a new resolved promise for the provided value.\n */\nexports.resolvedPromise = (value) => {\n    return Promise.resolve(value);\n};\n/**\n * Creates a new rejected promise for the provided reason.\n */\nexports.rejectedPromise = err => {\n    return Promise.reject(err);\n};\nexports.promisify = util.promisify;\nexports.map = (inputArg, functionArg) => __awaiter(this, void 0, void 0, function* () {\n    let promisifedFunction = exports.promisify(functionArg);\n    let promiseArray = [];\n    let resultArray = [];\n    for (let item of inputArg) {\n        let promise = promisifedFunction(item);\n        promiseArray.push(promise);\n        promise.then(x => {\n            resultArray.push(x);\n        });\n    }\n    yield Promise.all(promiseArray);\n    return resultArray;\n});\n","map":{"version":3,"file":"index.js","sourceRoot":"","sources":["../ts/index.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,6BAA6B;AAY7B;IAKE;QACE,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAChD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;YACvB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAZD,4BAYC;AAEU,QAAA,KAAK,GAAG,GAAM,EAAE;IACzB,OAAO,IAAI,QAAQ,EAAK,CAAC;AAC3B,CAAC,CAAC;AAEF;;GAEG;AACQ,QAAA,eAAe,GAAG,CAAI,KAAS,EAAc,EAAE;IACxD,OAAO,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAChC,CAAC,CAAC;AAEF;;GAEG;AACQ,QAAA,eAAe,GAAG,GAAG,CAAC,EAAE;IACjC,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC7B,CAAC,CAAC;AAES,QAAA,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;AAE3B,QAAA,GAAG,GAAG,CAAU,QAAa,EAAE,WAAW,EAAE,EAAE;IACvD,IAAI,kBAAkB,GAAG,iBAAS,CAAC,WAAW,CAAC,CAAC;IAChD,IAAI,YAAY,GAAmB,EAAE,CAAC;IACtC,IAAI,WAAW,GAAG,EAAE,CAAC;IACrB,KAAK,IAAI,IAAI,IAAI,QAAQ,EAAE;QACzB,IAAI,OAAO,GAAiB,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACrD,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC3B,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;YACf,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;KACJ;IACD,MAAM,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IAChC,OAAO,WAAW,CAAC;AACrB,CAAC,CAAA,CAAC","sourcesContent":["import * as util from 'util';\n\nexport interface IResolve<T> {\n  (value?: T | Promise<T>): void;\n}\n\nexport interface IReject {\n  (reason?: any): void;\n}\n\nexport type TDeferredStatus = 'pending' | 'fulfilled' | 'rejected';\n\nexport class Deferred<T> {\n  promise: Promise<T>;\n  resolve: IResolve<T>;\n  reject: IReject;\n  status: TDeferredStatus;\n  constructor() {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      this.status = 'pending';\n    });\n  }\n}\n\nexport let defer = <T>() => {\n  return new Deferred<T>();\n};\n\n/**\n * Creates a new resolved promise for the provided value.\n */\nexport let resolvedPromise = <T>(value?: T): Promise<T> => {\n  return Promise.resolve(value);\n};\n\n/**\n * Creates a new rejected promise for the provided reason.\n */\nexport let rejectedPromise = err => {\n  return Promise.reject(err);\n};\n\nexport let promisify = util.promisify;\n\nexport let map = async <T>(inputArg: T[], functionArg) => {\n  let promisifedFunction = promisify(functionArg);\n  let promiseArray: Promise<any>[] = [];\n  let resultArray = [];\n  for (let item of inputArg) {\n    let promise: Promise<any> = promisifedFunction(item);\n    promiseArray.push(promise);\n    promise.then(x => {\n      resultArray.push(x);\n    });\n  }\n  await Promise.all(promiseArray);\n  return resultArray;\n};\n"]}},"hash":"dc794a384f6a021da88975e60827dab9","cacheData":{"env":{}}}