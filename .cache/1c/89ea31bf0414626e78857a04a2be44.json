{"id":"../node_modules/@pushrocks/lik/dist/lik.stringmap.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/ts/lik.stringmap.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/package.json","includedInParent":true,"mtime":1545395695572},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/package.json","includedInParent":true,"mtime":1545395355371},{"name":"./lik.plugins","loc":{"line":3,"column":24},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/dist/lik.stringmap.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/dist/lik.plugins.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst plugins = require(\"./lik.plugins\");\nclass Stringmap {\n    constructor() {\n        this._stringArray = [];\n        this._triggerUntilTrueFunctionArray = [];\n    }\n    /**\n     * add a string to the Stringmap\n     */\n    addString(stringArg) {\n        this._stringArray.push(stringArg);\n        this.notifyTrigger();\n    }\n    /**\n     * like addString, but accepts an array of strings\n     */\n    addStringArray(stringArrayArg) {\n        for (let stringItem of stringArrayArg) {\n            this.addString(stringItem);\n        }\n    }\n    /**\n     * removes a string from Stringmap\n     */\n    removeString(stringArg) {\n        for (let keyArg in this._stringArray) {\n            if (this._stringArray[keyArg] === stringArg) {\n                this._stringArray.splice(parseInt(keyArg), 1);\n            }\n        }\n        this.notifyTrigger();\n    }\n    /**\n     * wipes the Stringmap\n     */\n    wipe() {\n        this._stringArray = [];\n        this.notifyTrigger();\n    }\n    /**\n     * check if string is in Stringmap\n     */\n    checkString(stringArg) {\n        return this._stringArray.indexOf(stringArg) !== -1;\n    }\n    /**\n     * checks stringPresence with minimatch\n     */\n    checkMinimatch(miniMatchStringArg) {\n        let foundMatch = false;\n        for (let stringItem of this._stringArray) {\n            if (plugins.minimatch(stringItem, miniMatchStringArg)) {\n                foundMatch = true;\n            }\n        }\n        return foundMatch;\n    }\n    /**\n     * checks if the Stringmap is empty\n     */\n    checkIsEmpty() {\n        return this._stringArray.length === 0;\n    }\n    /**\n     * gets a cloned copy of the current string Array\n     */\n    getStringArray() {\n        const returnArray = [];\n        for (const stringItem of this._stringArray) {\n            returnArray.push(stringItem);\n        }\n        return returnArray;\n    }\n    // trigger registering\n    /**\n     * register a new trigger\n     */\n    registerUntilTrue(functionArg, doFunctionArg) {\n        this._triggerUntilTrueFunctionArray.push(() => {\n            let result = functionArg();\n            if (result === true) {\n                doFunctionArg();\n            }\n            return result;\n        });\n        this.notifyTrigger();\n    }\n    /**\n     * notifies triggers\n     */\n    notifyTrigger() {\n        let filteredArray = this._triggerUntilTrueFunctionArray.filter(functionArg => {\n            return !functionArg();\n        });\n        this._triggerUntilTrueFunctionArray = filteredArray;\n    }\n}\nexports.Stringmap = Stringmap;\n","map":{"version":3,"file":"lik.stringmap.js","sourceRoot":"","sources":["../ts/lik.stringmap.ts"],"names":[],"mappings":";;AAAA,yCAAyC;AAUzC,MAAa,SAAS;IAGpB;QAFQ,iBAAY,GAAa,EAAE,CAAC;QAC5B,mCAA8B,GAAuB,EAAE,CAAC;IACjD,CAAC;IAChB;;OAEG;IACH,SAAS,CAAC,SAAiB;QACzB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAClC,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED;;OAEG;IACH,cAAc,CAAC,cAAwB;QACrC,KAAK,IAAI,UAAU,IAAI,cAAc,EAAE;YACrC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;SAC5B;IACH,CAAC;IAED;;OAEG;IACH,YAAY,CAAC,SAAiB;QAC5B,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,YAAY,EAAE;YACpC,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,KAAK,SAAS,EAAE;gBAC3C,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;aAC/C;SACF;QACD,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED;;OAEG;IACH,IAAI;QACF,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;QACvB,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED;;OAEG;IACI,WAAW,CAAC,SAAiB;QAClC,OAAO,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;IACrD,CAAC;IAED;;OAEG;IACI,cAAc,CAAC,kBAA0B;QAC9C,IAAI,UAAU,GAAY,KAAK,CAAC;QAChC,KAAK,IAAI,UAAU,IAAI,IAAI,CAAC,YAAY,EAAE;YACxC,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,EAAE,kBAAkB,CAAC,EAAE;gBACrD,UAAU,GAAG,IAAI,CAAC;aACnB;SACF;QACD,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;;OAEG;IACI,YAAY;QACjB,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC,CAAC;IACxC,CAAC;IAED;;OAEG;IACI,cAAc;QACnB,MAAM,WAAW,GAAa,EAAE,CAAC;QACjC,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,YAAY,EAAE;YAC1C,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SAC9B;QACD,OAAO,WAAW,CAAC;IACrB,CAAC;IAED,sBAAsB;IAEtB;;OAEG;IACI,iBAAiB,CAAC,WAA6B,EAAE,aAAa;QACnE,IAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,GAAG,EAAE;YAC5C,IAAI,MAAM,GAAG,WAAW,EAAE,CAAC;YAC3B,IAAI,MAAM,KAAK,IAAI,EAAE;gBACnB,aAAa,EAAE,CAAC;aACjB;YACD,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED;;OAEG;IACK,aAAa;QACnB,IAAI,aAAa,GAAG,IAAI,CAAC,8BAA8B,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE;YAC3E,OAAO,CAAC,WAAW,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,8BAA8B,GAAG,aAAa,CAAC;IACtD,CAAC;CACF;AAxGD,8BAwGC","sourcesContent":["import * as plugins from './lik.plugins';\n\n/**\n * allows you to easily keep track of a bunch of strings\n */\n\nexport interface ITriggerFunction {\n  (): boolean;\n}\n\nexport class Stringmap {\n  private _stringArray: string[] = [];\n  private _triggerUntilTrueFunctionArray: ITriggerFunction[] = [];\n  constructor() {}\n  /**\n   * add a string to the Stringmap\n   */\n  addString(stringArg: string) {\n    this._stringArray.push(stringArg);\n    this.notifyTrigger();\n  }\n\n  /**\n   * like addString, but accepts an array of strings\n   */\n  addStringArray(stringArrayArg: string[]) {\n    for (let stringItem of stringArrayArg) {\n      this.addString(stringItem);\n    }\n  }\n\n  /**\n   * removes a string from Stringmap\n   */\n  removeString(stringArg: string) {\n    for (let keyArg in this._stringArray) {\n      if (this._stringArray[keyArg] === stringArg) {\n        this._stringArray.splice(parseInt(keyArg), 1);\n      }\n    }\n    this.notifyTrigger();\n  }\n\n  /**\n   * wipes the Stringmap\n   */\n  wipe() {\n    this._stringArray = [];\n    this.notifyTrigger();\n  }\n\n  /**\n   * check if string is in Stringmap\n   */\n  public checkString(stringArg: string): boolean {\n    return this._stringArray.indexOf(stringArg) !== -1;\n  }\n\n  /**\n   * checks stringPresence with minimatch\n   */\n  public checkMinimatch(miniMatchStringArg: string): boolean {\n    let foundMatch: boolean = false;\n    for (let stringItem of this._stringArray) {\n      if (plugins.minimatch(stringItem, miniMatchStringArg)) {\n        foundMatch = true;\n      }\n    }\n    return foundMatch;\n  }\n\n  /**\n   * checks if the Stringmap is empty\n   */\n  public checkIsEmpty() {\n    return this._stringArray.length === 0;\n  }\n\n  /**\n   * gets a cloned copy of the current string Array\n   */\n  public getStringArray() {\n    const returnArray: string[] = [];\n    for (const stringItem of this._stringArray) {\n      returnArray.push(stringItem);\n    }\n    return returnArray;\n  }\n\n  // trigger registering\n\n  /**\n   * register a new trigger\n   */\n  public registerUntilTrue(functionArg: ITriggerFunction, doFunctionArg) {\n    this._triggerUntilTrueFunctionArray.push(() => {\n      let result = functionArg();\n      if (result === true) {\n        doFunctionArg();\n      }\n      return result;\n    });\n    this.notifyTrigger();\n  }\n\n  /**\n   * notifies triggers\n   */\n  private notifyTrigger() {\n    let filteredArray = this._triggerUntilTrueFunctionArray.filter(functionArg => {\n      return !functionArg();\n    });\n    this._triggerUntilTrueFunctionArray = filteredArray;\n  }\n}\n"]}},"hash":"a0a4ecaa8a341a37c69f325aa6e5a55f","cacheData":{"env":{}}}