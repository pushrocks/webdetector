{"id":"../node_modules/@pushrocks/smartrx/dist/smartrx.classes.observablemap.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/ts/smartrx.classes.observablemap.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/package.json","includedInParent":true,"mtime":1545395695572},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/package.json","includedInParent":true,"mtime":1545395355372},{"name":"rxjs","loc":{"line":3,"column":23},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/dist/smartrx.classes.observablemap.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/rxjs/_esm5/index.js"},{"name":"@pushrocks/lik","loc":{"line":4,"column":22},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smartrx/dist/smartrx.classes.observablemap.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/dist/index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rxjs_1 = require(\"rxjs\");\nconst lik_1 = require(\"@pushrocks/lik\");\n/**\n * manages observables by making sure that only one observable is regsitered per event\n */\nclass Observablemap {\n    constructor() {\n        this.ObservableEmitterBundleObjectmap = new lik_1.Objectmap();\n    }\n    /**\n     * creates a new observable if not yet registered for the same event.\n     * In case event has been registered before the same observable is returned.\n     */\n    getObservableForEmitterEvent(emitterArg, eventArg) {\n        let existingBundle = this.ObservableEmitterBundleObjectmap.find(bundleArg => {\n            return bundleArg.emitter === emitterArg && bundleArg.event === eventArg;\n        });\n        if (existingBundle) {\n            return existingBundle.observable;\n        }\n        else {\n            let emitterObservable = rxjs_1.fromEvent(emitterArg, eventArg);\n            this.ObservableEmitterBundleObjectmap.add({\n                observable: emitterObservable,\n                emitter: emitterArg,\n                event: eventArg\n            });\n            return emitterObservable;\n        }\n    }\n}\nexports.Observablemap = Observablemap;\n","map":{"version":3,"file":"smartrx.classes.observablemap.js","sourceRoot":"","sources":["../ts/smartrx.classes.observablemap.ts"],"names":[],"mappings":";;AACA,+BAA6C;AAC7C,wCAAsD;AAUtD;;GAEG;AACH,MAAa,aAAa;IAA1B;QACE,qCAAgC,GAAG,IAAI,eAAS,EAA2B,CAAC;IAsB9E,CAAC;IApBC;;;OAGG;IACH,4BAA4B,CAAC,UAAuC,EAAE,QAAgB;QACpF,IAAI,cAAc,GAAG,IAAI,CAAC,gCAAgC,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;YAC1E,OAAO,SAAS,CAAC,OAAO,KAAK,UAAU,IAAI,SAAS,CAAC,KAAK,KAAK,QAAQ,CAAC;QAC1E,CAAC,CAAC,CAAC;QACH,IAAI,cAAc,EAAE;YAClB,OAAO,cAAc,CAAC,UAAU,CAAC;SAClC;aAAM;YACL,IAAI,iBAAiB,GAAG,gBAAS,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;YACxD,IAAI,CAAC,gCAAgC,CAAC,GAAG,CAAC;gBACxC,UAAU,EAAE,iBAAiB;gBAC7B,OAAO,EAAE,UAAU;gBACnB,KAAK,EAAE,QAAQ;aAChB,CAAC,CAAC;YACH,OAAO,iBAAiB,CAAC;SAC1B;IACH,CAAC;CACF;AAvBD,sCAuBC","sourcesContent":["import * as plugins from './smartrx.plugins';\nimport { Observable, fromEvent } from 'rxjs';\nimport { Objectmap, Stringmap } from '@pushrocks/lik';\n/**\n * bundles an observable with an emitter\n */\nexport interface ObservableEmitterBundle {\n  observable: plugins.rxjs.Observable<any>;\n  emitter: plugins.events.EventEmitter;\n  event: string;\n}\n\n/**\n * manages observables by making sure that only one observable is regsitered per event\n */\nexport class Observablemap {\n  ObservableEmitterBundleObjectmap = new Objectmap<ObservableEmitterBundle>();\n\n  /**\n   * creates a new observable if not yet registered for the same event.\n   * In case event has been registered before the same observable is returned.\n   */\n  getObservableForEmitterEvent(emitterArg: plugins.events.EventEmitter, eventArg: string) {\n    let existingBundle = this.ObservableEmitterBundleObjectmap.find(bundleArg => {\n      return bundleArg.emitter === emitterArg && bundleArg.event === eventArg;\n    });\n    if (existingBundle) {\n      return existingBundle.observable;\n    } else {\n      let emitterObservable = fromEvent(emitterArg, eventArg);\n      this.ObservableEmitterBundleObjectmap.add({\n        observable: emitterObservable,\n        emitter: emitterArg,\n        event: eventArg\n      });\n      return emitterObservable;\n    }\n  }\n}\n"]}},"hash":"63dcbf481c687a68f869b61aa68395ae","cacheData":{"env":{}}}