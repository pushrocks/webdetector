{"id":"../node_modules/@pushrocks/lik/dist/lik.objectmap.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/ts/lik.objectmap.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/package.json","includedInParent":true,"mtime":1545395695572},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/lik/package.json","includedInParent":true,"mtime":1545395355371}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * allows keeping track of objects\n */\nclass Objectmap {\n    /**\n     * returns a new instance\n     */\n    constructor() {\n        this.objectArray = [];\n        // nothing here\n    }\n    /**\n     * add object to Objectmap\n     * returns false if the object is already in the map\n     * returns true if the object was added successfully\n     */\n    add(objectArg) {\n        if (this.checkForObject(objectArg)) {\n            // the object is already in the objectmap\n            return false;\n        }\n        else {\n            // the object is not yet in the objectmap\n            this.objectArray.push(objectArg);\n            return true;\n        }\n    }\n    /**\n     * like .add but adds an whole array of objects\n     */\n    addArray(objectArrayArg) {\n        for (let item of objectArrayArg) {\n            this.add(item);\n        }\n    }\n    /**\n     * check if object is in Objectmap\n     */\n    checkForObject(objectArg) {\n        return this.objectArray.indexOf(objectArg) !== -1;\n    }\n    /**\n     * find object\n     */\n    find(findFunction) {\n        const resultArray = this.objectArray.filter(findFunction);\n        if (resultArray.length > 0) {\n            return resultArray[0];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * finds a specific element and then removes it\n     */\n    findOneAndRemove(findFunction) {\n        const foundElement = this.find(findFunction);\n        if (foundElement) {\n            this.remove(foundElement);\n        }\n        return foundElement;\n    }\n    /**\n     * run function for each item in Objectmap\n     */\n    forEach(functionArg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let object of this.objectArray) {\n                yield functionArg(object);\n            }\n        });\n    }\n    /**\n     * gets an object in the Observablemap and removes it, so it can't be retrieved again\n     */\n    getOneAndRemove() {\n        return this.objectArray.shift();\n    }\n    /**\n     * returns a cloned array of all the objects currently in the Objectmap\n     */\n    getArray() {\n        const returnArray = [];\n        for (const objectItem of this.objectArray) {\n            returnArray.push(objectItem);\n        }\n        return returnArray;\n    }\n    /**\n     * check if Objectmap ist empty\n     */\n    isEmpty() {\n        if (this.objectArray.length === 0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * remove object from Objectmap\n     */\n    remove(objectArg) {\n        let replacementArray = [];\n        for (let item of this.objectArray) {\n            if (item !== objectArg) {\n                replacementArray.push(item);\n            }\n        }\n        this.objectArray = replacementArray;\n    }\n    /**\n     * wipe Objectmap\n     */\n    wipe() {\n        this.objectArray = [];\n    }\n}\nexports.Objectmap = Objectmap;\n","map":{"version":3,"file":"lik.objectmap.js","sourceRoot":"","sources":["../ts/lik.objectmap.ts"],"names":[],"mappings":";;;;;;;;;;AAUA;;GAEG;AACH,MAAa,SAAS;IAGpB;;OAEG;IACH;QALQ,gBAAW,GAAQ,EAAE,CAAC;QAM5B,eAAe;IACjB,CAAC;IAED;;;;OAIG;IACI,GAAG,CAAC,SAAY;QACrB,IAAI,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;YAClC,yCAAyC;YACzC,OAAO,KAAK,CAAC;SACd;aAAM;YACL,yCAAyC;YACzC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACjC,OAAO,IAAI,CAAC;SACb;IACH,CAAC;IAED;;OAEG;IACI,QAAQ,CAAC,cAAmB;QACjC,KAAK,IAAI,IAAI,IAAI,cAAc,EAAE;YAC/B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SAChB;IACH,CAAC;IAED;;OAEG;IACI,cAAc,CAAC,SAAY;QAChC,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;IACpD,CAAC;IAED;;OAEG;IACI,IAAI,CAAC,YAAuC;QACjD,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;QAC1D,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;YAC1B,OAAO,WAAW,CAAC,CAAC,CAAC,CAAC;SACvB;aAAM;YACL,OAAO,IAAI,CAAC;SACb;IACH,CAAC;IAED;;OAEG;IACI,gBAAgB,CAAC,YAAuC;QAC7D,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC7C,IAAI,YAAY,EAAE;YAChB,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;SAC3B;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;OAEG;IACU,OAAO,CAAC,WAAyC;;YAC5D,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,WAAW,EAAE;gBACnC,MAAM,WAAW,CAAC,MAAM,CAAC,CAAC;aAC3B;QACH,CAAC;KAAA;IAED;;OAEG;IACI,eAAe;QACpB,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;IAClC,CAAC;IAED;;OAEG;IACI,QAAQ;QACb,MAAM,WAAW,GAAU,EAAE,CAAC;QAC9B,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,WAAW,EAAE;YACzC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SAC9B;QACD,OAAO,WAAW,CAAC;IACrB,CAAC;IAED;;OAEG;IACI,OAAO;QACZ,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;YACjC,OAAO,IAAI,CAAC;SACb;aAAM;YACL,OAAO,KAAK,CAAC;SACd;IACH,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,SAAY;QACxB,IAAI,gBAAgB,GAAG,EAAE,CAAC;QAC1B,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,WAAW,EAAE;YACjC,IAAI,IAAI,KAAK,SAAS,EAAE;gBACtB,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAC7B;SACF;QACD,IAAI,CAAC,WAAW,GAAG,gBAAgB,CAAC;IACtC,CAAC;IAED;;OAEG;IACI,IAAI;QACT,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;IACxB,CAAC;CACF;AA1HD,8BA0HC","sourcesContent":["import * as plugins from './lik.plugins';\n\nexport interface IObjectmapForEachFunction<T> {\n  (itemArg: T): void;\n}\n\nexport interface IObjectmapFindFunction<T> {\n  (itemArg: T): boolean;\n}\n\n/**\n * allows keeping track of objects\n */\nexport class Objectmap<T> {\n  private objectArray: T[] = [];\n\n  /**\n   * returns a new instance\n   */\n  constructor() {\n    // nothing here\n  }\n\n  /**\n   * add object to Objectmap\n   * returns false if the object is already in the map\n   * returns true if the object was added successfully\n   */\n  public add(objectArg: T): boolean {\n    if (this.checkForObject(objectArg)) {\n      // the object is already in the objectmap\n      return false;\n    } else {\n      // the object is not yet in the objectmap\n      this.objectArray.push(objectArg);\n      return true;\n    }\n  }\n\n  /**\n   * like .add but adds an whole array of objects\n   */\n  public addArray(objectArrayArg: T[]) {\n    for (let item of objectArrayArg) {\n      this.add(item);\n    }\n  }\n\n  /**\n   * check if object is in Objectmap\n   */\n  public checkForObject(objectArg: T) {\n    return this.objectArray.indexOf(objectArg) !== -1;\n  }\n\n  /**\n   * find object\n   */\n  public find(findFunction: IObjectmapFindFunction<T>) {\n    const resultArray = this.objectArray.filter(findFunction);\n    if (resultArray.length > 0) {\n      return resultArray[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * finds a specific element and then removes it\n   */\n  public findOneAndRemove(findFunction: IObjectmapFindFunction<T>): T {\n    const foundElement = this.find(findFunction);\n    if (foundElement) {\n      this.remove(foundElement);\n    }\n    return foundElement;\n  }\n\n  /**\n   * run function for each item in Objectmap\n   */\n  public async forEach(functionArg: IObjectmapForEachFunction<T>) {\n    for (let object of this.objectArray) {\n      await functionArg(object);\n    }\n  }\n\n  /**\n   * gets an object in the Observablemap and removes it, so it can't be retrieved again\n   */\n  public getOneAndRemove(): T {\n    return this.objectArray.shift();\n  }\n\n  /**\n   * returns a cloned array of all the objects currently in the Objectmap\n   */\n  public getArray() {\n    const returnArray: any[] = [];\n    for (const objectItem of this.objectArray) {\n      returnArray.push(objectItem);\n    }\n    return returnArray;\n  }\n\n  /**\n   * check if Objectmap ist empty\n   */\n  public isEmpty(): boolean {\n    if (this.objectArray.length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * remove object from Objectmap\n   */\n  public remove(objectArg: T) {\n    let replacementArray = [];\n    for (let item of this.objectArray) {\n      if (item !== objectArg) {\n        replacementArray.push(item);\n      }\n    }\n    this.objectArray = replacementArray;\n  }\n\n  /**\n   * wipe Objectmap\n   */\n  public wipe() {\n    this.objectArray = [];\n  }\n}\n"]}},"hash":"9ea0f7b3bde01036e133865af5489fe6","cacheData":{"env":{}}}