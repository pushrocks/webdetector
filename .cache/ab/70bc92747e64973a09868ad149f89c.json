{"id":"../node_modules/@pushrocks/smarttime/dist/smarttime.classes.timer.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smarttime/ts/smarttime.classes.timer.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/package.json","includedInParent":true,"mtime":1545395695572},{"name":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smarttime/package.json","includedInParent":true,"mtime":1545395356342},{"name":"./smarttime.plugins","loc":{"line":3,"column":24},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smarttime/dist/smarttime.classes.timer.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smarttime/dist/smarttime.plugins.js"},{"name":"./smarttime.classes.timestamp","loc":{"line":4,"column":46},"parent":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smarttime/dist/smarttime.classes.timer.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/webdetector/node_modules/@pushrocks/smarttime/dist/smarttime.classes.timestamp.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst plugins = require(\"./smarttime.plugins\");\nconst smarttime_classes_timestamp_1 = require(\"./smarttime.classes.timestamp\");\nclass Timer {\n    constructor(timeInMillisecondsArg) {\n        /**\n         * the state of the timer\n         */\n        this.state = 'initiated';\n        // a deferred triggeted when Timer has completed\n        this.completedDeferred = plugins.smartpromise.defer();\n        this.timeInMilliseconds = timeInMillisecondsArg;\n        this.completed = this.completedDeferred.promise;\n    }\n    get timeLeft() {\n        return this.timeInMilliseconds - this.pausedAt.change;\n    }\n    /**\n     * starts the timer\n     */\n    start() {\n        if (!this.startedAt) {\n            this.currentTimeout = setTimeout(() => {\n                this.completedDeferred.resolve();\n            }, this.timeInMilliseconds);\n            this.startedAt = new smarttime_classes_timestamp_1.TimeStamp();\n        }\n        else {\n            throw new Error('timer has been started before. Please use resume instead');\n        }\n    }\n    pause() {\n        if (this.startedAt) {\n            clearTimeout(this.currentTimeout);\n            this.currentTimeout = null;\n            this.pausedAt = smarttime_classes_timestamp_1.TimeStamp.fromTimeStamp(this.startedAt);\n        }\n    }\n    resume() {\n        if (this.startedAt) {\n            this.currentTimeout = setTimeout(() => {\n                this.completedDeferred.resolve();\n            }, this.timeLeft);\n        }\n        else {\n            throw new Error('timer has NOT been started before. Please use .start() instead');\n        }\n    }\n    reset() {\n        this.pause();\n        this.startedAt = null;\n        this.pausedAt = null;\n    }\n}\nexports.Timer = Timer;\n","map":{"version":3,"file":"smarttime.classes.timer.js","sourceRoot":"","sources":["../ts/smarttime.classes.timer.ts"],"names":[],"mappings":";;AAAA,+CAA+C;AAE/C,+EAA0D;AAI1D,MAAa,KAAK;IAqChB,YAAY,qBAA6B;QA/BzC;;WAEG;QACI,UAAK,GAAe,WAAW,CAAC;QAyBvC,gDAAgD;QACxC,sBAAiB,GAAG,OAAO,CAAC,YAAY,CAAC,KAAK,EAAQ,CAAC;QAG7D,IAAI,CAAC,kBAAkB,GAAG,qBAAqB,CAAC;QAChD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC;IAClD,CAAC;IAdD,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;IACxD,CAAC;IAcD;;OAEG;IACI,KAAK;QACV,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC,GAAG,EAAE;gBACpC,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,CAAC;YACnC,CAAC,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;YAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,uCAAS,EAAE,CAAC;SAClC;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;SAC7E;IACH,CAAC;IAEM,KAAK;QACV,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,YAAY,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YAClC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;YAC3B,IAAI,CAAC,QAAQ,GAAG,uCAAS,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SACzD;IACH,CAAC;IAEM,MAAM;QACX,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC,GAAG,EAAE;gBACpC,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,CAAC;YACnC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SACnB;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,gEAAgE,CAAC,CAAC;SACnF;IACH,CAAC;IAEM,KAAK;QACV,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACvB,CAAC;CACF;AA/ED,sBA+EC","sourcesContent":["import * as plugins from './smarttime.plugins';\n\nimport { TimeStamp } from './smarttime.classes.timestamp';\n\nexport type TimerState = 'initiated' | 'started' | 'paused' | 'completed';\n\nexport class Timer {\n  /**\n   * the original amount of milliseconds for this Timer\n   */\n  public timeInMilliseconds: number;\n\n  /**\n   * the state of the timer\n   */\n  public state: TimerState = 'initiated';\n\n  /**\n   * completed Promise\n   */\n  public completed: Promise<void>;\n\n  /**\n   * a reference to when the Timeout started\n   */\n  public startedAt: TimeStamp;\n\n  /**\n   * a reference to when a Timer has been potentially paused\n   */\n  public pausedAt: TimeStamp;\n\n  get timeLeft(): number {\n    return this.timeInMilliseconds - this.pausedAt.change;\n  }\n  /**\n   * the current timeout the needs to be canceled when this Timer is stopped\n   */\n  private currentTimeout: NodeJS.Timer;\n\n  // a deferred triggeted when Timer has completed\n  private completedDeferred = plugins.smartpromise.defer<void>();\n\n  constructor(timeInMillisecondsArg: number) {\n    this.timeInMilliseconds = timeInMillisecondsArg;\n    this.completed = this.completedDeferred.promise;\n  }\n\n  /**\n   * starts the timer\n   */\n  public start() {\n    if (!this.startedAt) {\n      this.currentTimeout = setTimeout(() => {\n        this.completedDeferred.resolve();\n      }, this.timeInMilliseconds);\n      this.startedAt = new TimeStamp();\n    } else {\n      throw new Error('timer has been started before. Please use resume instead');\n    }\n  }\n\n  public pause() {\n    if (this.startedAt) {\n      clearTimeout(this.currentTimeout);\n      this.currentTimeout = null;\n      this.pausedAt = TimeStamp.fromTimeStamp(this.startedAt);\n    }\n  }\n\n  public resume() {\n    if (this.startedAt) {\n      this.currentTimeout = setTimeout(() => {\n        this.completedDeferred.resolve();\n      }, this.timeLeft);\n    } else {\n      throw new Error('timer has NOT been started before. Please use .start() instead');\n    }\n  }\n\n  public reset() {\n    this.pause();\n    this.startedAt = null;\n    this.pausedAt = null;\n  }\n}\n"]}},"hash":"9e7b2d3efe146a61a59cb4e7b958b92b","cacheData":{"env":{}}}